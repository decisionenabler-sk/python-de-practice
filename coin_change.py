# You are given an integer array coins representing coins of different denominations 
# and an integer target_amount representing a total amount of money.
# Return the fewest number of coins that you need to make up that amount. 
# If that amount of money cannot be made up by any combination of the coins, return -1.

# You may assume that you have an infinite number of each kind of coin

# Input: coins = [2, 4, 1, 4], target_amount = 5
# Output: 2

# Input: coins = [2], target_amount = 3
# Output: -1

# slow thinking : if sum of coins is less than target_amount, return -1, 
# find max value coin and find the difference 
# if difference is less than the max value of remaining coins then repeat until difference is 0 or less than 0, 
# if difference is less than 0 then return -1, else return the number of coins used

def get_coins(coins, target_amount):
    # handling the case where the sum of coins is less than target_amount
    if  sum(coins) < target_amount or min(coins) > target_amount:
        return -1
    # Initializing the count of coins and the difference
    count = 0
    difference = target_amount
    # loop until the difference is 0 or less than 0
    while difference > 0:
        difference = target_amount - max(coins)
        count += 1
        target_amount = difference
    return count
# test cases
print("Number of coins needed:",get_coins([2], 3))
print("Number of coins needed:",get_coins([2, 4, 1, 4], 5))

# Additional test cases generated by AI

print("Number of coins needed:", get_coins([1, 1, 1, 1], 4))  #  duplicate coins
print("Number of coins needed:", get_coins([9, 6, 5, 1], 11))  # non-sorted input
print("Number of coins needed:", get_coins([2, 3, 5], 1))  # target less than min coin (we don't wanna pay more!)
print("Number of coins needed:", get_coins([], 5))  #  empty coin array